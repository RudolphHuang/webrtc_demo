# WebRTC Demo — API and Component Reference

This document describes the public routes, components, and key functions available in this Vue 3 application. It also includes examples and usage instructions.

## Overview
- Framework: Vue 3, Vue Router 4, Vuex 4
- Networking: WebSocket signaling server (`wss`/`https` endpoint) and Axios for REST GET
- Media: WebRTC (RTCPeerConnection, MediaStream) and optional HLS ingestion via `hls.js`

## Getting Started
- Install dependencies:
  ```bash
yarn install
  ```
- Run the app in development mode:
  ```bash
yarn serve
  ```
- Build for production:
  ```bash
yarn build
  ```

## Routes and Views
The application exposes the following public routes via `vue-router`.

| Route | Name | Component | Purpose |
| --- | --- | --- | --- |
| `/` | `home` | `HomeView.vue` | Standard 1:1 WebRTC flow using a signaling server. Supports Start/Call/Answer/Hangup. |
| `/loop` | `loop` | `LoopView.vue` | Local loopback demo using two RTCPeerConnections in the same page (no signaling server). |
| `/seed` | `seed` | `SeedView.vue` | Seed a remote HLS `.m3u8` into WebRTC using `canvas.captureStream()`. |
| `/viewer` | `viewer` | `ViewerView.vue` | Viewer-only flow: receive and watch an existing call identified by Call ID. |

See `src/router/index.js` for definitions.

## Configuration
- `vue.config.js`
  - `publicPath`: `/webrtc_demo/` in production, `/` in development.
  - `devServer.proxy['/hls']`: proxies to `https://live.prd.dlive.tv` to help during local development of HLS.
- Signaling endpoint: Each view defines a `ws_url` or uses a literal URL to connect to the server:
  - Default: `https://webrtcserverdemo-production.up.railway.app/`
  - To customize, change the `ws_url` constant at the top of `HomeView.vue`, `ViewerView.vue`, and `SeedView.vue`.
- STUN/TURN: Each view defines a `servers` object passed to `RTCPeerConnection`. Update its `iceServers` list to use your own STUN/TURN infrastructure if needed.

Example `servers` object:
```js
const servers = {
  iceServers: [
    { urls: ['stun:stun.l.google.com:19302'] },
    // { urls: 'turn:your.turn.host:3478', username: 'user', credential: 'pass' }
  ],
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all'
};
```

## Signaling Message Contract
This app communicates with a signaling server over WebSocket and a small REST endpoint. Messages are JSON payloads with these shapes:

- Offer (client → server):
  ```json
  { "type": "offer", "callId": "ABCD", "offer": { "type": "offer", "sdp": "..." } }
  ```
- Answer (client → server):
  ```json
  { "type": "answer", "callId": "ABCD", "answer": { "type": "answer", "sdp": "..." } }
  ```
- ICE candidate (client → server):
  ```json
  { "type": "candidate", "callId": "ABCD", "candidate": { /* RTCIceCandidate JSON */ } }
  ```
- Join (client → server):
  ```json
  { "type": "join", "callId": "ABCD" }
  ```
- Fetch offer (client → REST):
  - `GET {ws_url}/offer/{callId}` → `{ offer, callerCandidates }`

Terminology
- Call ID: A short identifier generated by the caller or provided by the server that identifies a session.

## Components

### HelloWorld.vue
- Name: `HelloWorld`
- Props:
  - `msg: String` — message displayed as heading
- Usage:
  ```vue
  <template>
    <HelloWorld msg="Welcome to WebRTC Demo" />
  </template>

  <script>
  import HelloWorld from '@/components/HelloWorld.vue'
  export default { components: { HelloWorld } }
  </script>
  ```

## Views

### HomeView.vue (`/`)
- Purpose: Full 1:1 WebRTC example with Start/Call/Answer/Hangup using a signaling server
- Key data:
  - `localStream: MediaStream | null`
  - `remoteStream: MediaStream | null`
  - `pc: RTCPeerConnection`
  - `socket: WebSocket`
  - `callId: string`
  - Button states: `callButtonDisabled`, `answerButtonDisabled`, `webcamButtonDisabled`, `hangButtonDisabled`
  - `connectionState: RTCPeerConnectionState`
- Methods (UI-bound):
  - `start()`: Ask for camera, create `localStream`, attach to `<video ref="webcamVideo">`. Prepares `remoteStream` and tracks.
  - `call()`: Caller flow. Creates offer, sets local description, sends `offer` and ICE `candidate` messages over WebSocket. Generates `callId`.
  - `answer()`: Callee flow. Loads offer via `GET {ws_url}/offer/{callId}`, sets remote description, creates answer, sets local description, sends `answer` and ICE `candidate` messages. Adds caller ICE candidates.
  - `hangup()`: Closes RTCPeerConnection and reloads page.
- Example flow: create and answer a call
  1) In Browser A (caller): Click “Start webcam” → “Create Call (offer)”. Share the displayed Call ID.
  2) In Browser B (callee): Enter Call ID → click “Answer”.
  3) Media flows: Browser A local stream appears locally; remote stream appears once negotiation completes.
- Customization:
  - Update `ws_url` to point at your own signaling server.
  - Modify `servers.iceServers` to add TURN for NAT traversal.

### LoopView.vue (`/loop`)
- Purpose: Local loopback test with two RTCPeerConnections (`pc1` and `pc2`) in the same tab. Demonstrates offer/answer without a signaling server.
- Methods (UI-bound):
  - `start()`: Requests local media and enables the “Create Call (offer)” button.
  - `create()`: Creates an offer on `pc1`, sets local/remote descriptions across `pc1`/`pc2`, then creates and applies the answer on `pc2`.
  - `hangup()`: Closes both peer connections and resets UI state.
- Useful for verifying that local capture/decoding works independent of networking.

### SeedView.vue (`/seed`)
- Purpose: Ingest a remote HLS `.m3u8` into a WebRTC call. Draws HLS video onto a `<canvas>` and publishes `canvas.captureStream(25)` to the peer connection.
- Key data:
  - `m3u8_url: string` — default is `https://hn.bfvvs.com/play/wdLQLwje/index.m3u8`
  - Other fields are analogous to `HomeView` (`pc`, `socket`, `callId`, etc.)
- Methods (UI-bound):
  - `start()`: Use `hls.js` to play the HLS stream into a hidden `<video>`, render frames onto a canvas, then capture as `MediaStream` and add tracks to `pc`.
  - `call()`, `answer()`, `hangup()`: Same signaling flow as `HomeView`.
- Notes:
  - If your HLS host requires CORS adjustments, consider using the dev proxy at `/hls` when running locally.

### ViewerView.vue (`/viewer`)
- Purpose: Viewer-only page that joins an existing call by Call ID and plays the remote stream. It does not publish local media.
- Methods (UI-bound):
  - `answer()`: Fetches offer for `callId`, sets remote description, creates and sends an `answer`, adds caller ICE candidates.
  - `hangup()`: Closes RTCPeerConnection and reloads page.

## Programmatic Navigation Examples
```js
// In a setup where you have access to the router instance
import router from '@/router'

// Navigate to the viewer page
await router.push({ name: 'viewer' })

// Navigate to the seed page
await router.push({ path: '/seed' })
```

## Permissions & Troubleshooting
- Browser Permissions: The `start()` functions require camera/microphone permissions (except `ViewerView`, which only plays remote video).
- HTTPS: WebRTC getUserMedia and RTCPeerConnection generally require secure origins (`https://` or `localhost`).
- NAT Traversal: If remote peers cannot connect, configure a TURN server in `servers.iceServers`.
- HLS: If HLS playback fails in `SeedView`, verify CORS and the stream URL. Try the dev proxy (`/hls/...`) during local development.

## License
This documentation covers the client-side interfaces present in this repository. Review third-party dependencies for their respective licenses.